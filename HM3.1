for i=1
    delta = 1e-5; % tolerance for EM stopping criterion
    regWeight = 1e-10; % regularization parameter for covariance estimates
    N=10^i;%generate samples 10,100,1000,10000
    K=10;%10-FOLDER
    
    %generate samples from a 4-component GMM
    alpha_true=[0.1,0.2,0.3,0.4];
    mu_true=[[2;2],[-2;3],[-2;-2],[2;-3]];
    Sigma_true(:,:,1)=[3 1;1 20];
    Sigma_true(:,:,2)=[7 1;1 2];
    Sigma_true(:,:,3)=[4 1;1 16];
    Sigma_true(:,:,4)=[5 1;1 10];
    x=randGMM(N,alpha_true,mu_true,Sigma_true);
    [d,M]=size(mu_true)%determine dimensionality of samples and the number of GMM components
    
 %Divide the data set into K approximately-equal-sized partitions
    dummy = ceil(linspace(0,N,K+1));% generate k seperate datasets\ ceil Round towards plus infinity.
    for k = 1:K
        indPartitionLimits(k,:) = [dummy(k)+1,dummy(k+1)];
    end

    % Allocate space
    MSEtrain = zeros(K,N); MSEvalidate = zeros(K,N); 
    AverageMSEtrain = zeros(1,N); AverageMSEvalidate = zeros(1,N);
    for C=1:6%#order
        % Initialize the GMM to randomly selected samples
        alpha = ones(1,C)/C;
        shuffledIndices = randperm(N)
        mu = x(:,shuffledIndices(1:C)) % pick c random samples as initial mean estimates in the originial dataset x
        [~,assignedCentroidLabels] = min(pdist2(mu',x'),[],1); % assign each sample to the nearest mean
     %[D,I] = pdist2(X,Y,DISTANCE,'Smallest',K) returns a K-by-MY matrix I
    %containing indices of the observations in X corresponding to the K
    %smallest pairwise distances in D. [D,I] = pdist2(X,Y,DISTANCE,
    %'Largest',K) returns indices corresponding to the K largest pairwise distances.
        for m = 1:C % use sample covariances of initial assignments as initial covariance estimates
            Sigma(:,:,m) = cov(x(:,find(assignedCentroidLabels==m))') + regWeight*eye(d,d)
        end
         % K-fold cross validation
         %Divide the data set into K approximately-equal-sized partitions

                for k = 1:K
                    indValidate = [indPartitionLimits(k,1):indPartitionLimits(k,2)];
                    xValidate = x(indValidate); % Using folk k as validation set
                    yValidate = y(indValidate);
                    if k == 1
                        indTrain = [indPartitionLimits(k,2)+1:N];
                    elseif k == K
                        indTrain = [1:indPartitionLimits(k,1)-1];
                    else
                        indTrain = [indPartitionLimits(k-1,2)+1:indPartitionLimits(k+1,1)-1];
                    end
                    xTrain = x(indTrain); % using all other folds as training set
                    yTrain = y(indTrain);
                    Ntrain = length(indTrain); Nvalidate = length(indValidate);
                    % Train model parameters
                    [wML,MSEtrain(k,M)] = fitPolynomial(M,xTrain, yTrain, Ntrain);
                    PsiXvalidate = formPsiX(xValidate,M,Nvalidate);
                    MSEvalidate(k,M) = calculateMSE(yValidate,wML,PsiXvalidate);
                end
                AverageMSEtrain(1,M) = mean(MSEtrain(:,M)); % average training MSE over folds
                AverageMSEvalidate(1,M) = mean(MSEvalidate(:,M)); % average validation MSE over folds

    end
end

            
            


function x=randGMM(N,alpha,mu,Sigma)
d=size(mu,1);%dimensionality of samples
cum_alpha=[0,cumsum(alpha)];
u=rand(1,N);%randomly generate N numbers
x=zeros(d,N);labels=zeros(1,N);
for m=1:length(alpha)%iteration for the number of component
    ind=find(cum_alpha(m)<u & u<=cum_alpha(m+1));
    x(:,ind)=randGaussian(length(ind),mu(:,m),Sigma(:,:,m));%generate samples for each component
end
end

%generate N samples from a Gaussian pdf with mean mu and covariance Sigma
function x=randGaussian(N,mu,Sigma)
n=length(mu);
z=randn(n,N);
A=Sigma^(1/2);
x=A*z+repmat(mu,1,N);
end

% 
% function [x1Grid,x2Grid,zGMM] = contourGMM(alpha,mu,Sigma,rangex1,rangex2)
% x1Grid = linspace(floor(rangex1(1)),ceil(rangex1(2)),101);
% x2Grid = linspace(floor(rangex2(1)),ceil(rangex2(2)),91);
% [h,v] = meshgrid(x1Grid,x2Grid);
% GMM = evalGMM([h(:)';v(:)'],alpha, mu, Sigma);
% zGMM = reshape(GMM,91,101);
% %figure(1), contour(horizontalGrid,verticalGrid,discriminantScoreGrid,[minDSGV*[0.9,0.6,0.3],0,[0.3,0.6,0.9]*maxDSGV]); % plot equilevel contours of the discriminant function 
% end

function gmm = evalGMM(x,alpha,mu,Sigma)
gmm = zeros(1,size(x,2));
for m = 1:length(alpha) % evaluate the GMM on the grid
    gmm = gmm + alpha(m)*evalGaussian(x,mu(:,m),Sigma(:,:,m));
end
end
%%%

function g = evalGaussian(x,mu,Sigma)
% Evaluates the Gaussian pdf N(mu,Sigma) at each coumn of X
[n,N] = size(x);
invSigma = inv(Sigma);
C = (2*pi)^(-n/2) * det(invSigma)^(1/2);
E = -0.5*sum((x-repmat(mu,1,N)).*(invSigma*(x-repmat(mu,1,N))),1);
g = C*exp(E);
end
